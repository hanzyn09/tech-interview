# 자료구조 Q&A

## 배열과 리스트

### 배열 (Array)
같은 타입의 데이터를 연속된 메모리 공간에 저장하는 자료구조입니다.

**특징**:
- **고정 크기**: 선언 시 크기 결정
- **인덱스 접근**: O(1) 시간복잡도
- **메모리 효율**: 연속된 메모리 할당
- **캐시 친화적**: 지역성 원리 활용

**장점**: 빠른 랜덤 접근, 메모리 효율성
**단점**: 크기 고정, 삽입/삭제 비효율

### 리스트 (List)
동적으로 크기가 변할 수 있는 순서가 있는 자료구조입니다.

**ArrayList vs LinkedList**:
| 구분 | ArrayList | LinkedList |
|------|-----------|------------|
| 구조 | 동적 배열 | 이중 연결 리스트 |
| 접근 | O(1) | O(n) |
| 삽입/삭제 (중간) | O(n) | O(1) |
| 메모리 | 연속 | 비연속 |
| 캐시 성능 | 좋음 | 나쁨 |

## 스택과 큐

### 스택 (Stack)
LIFO(Last In First Out) 원칙을 따르는 자료구조입니다.

**주요 연산**:
- `push()`: 원소 삽입
- `pop()`: 원소 제거 및 반환
- `peek()/top()`: 최상단 원소 조회
- `isEmpty()`: 스택이 비어있는지 확인

**활용 사례**:
- 함수 호출 스택
- 괄호 매칭 검사
- 후위 표기법 계산
- 웹 브라우저 뒤로가기

### 큐 (Queue)
FIFO(First In First Out) 원칙을 따르는 자료구조입니다.

**주요 연산**:
- `enqueue()`: 원소 삽입
- `dequeue()`: 원소 제거 및 반환
- `front()`: 맨 앞 원소 조회
- `isEmpty()`: 큐가 비어있는지 확인

**큐의 종류**:
- **선형 큐**: 일반적인 큐
- **원형 큐**: 배열의 끝과 시작이 연결
- **우선순위 큐**: 우선순위에 따라 처리
- **덱(Deque)**: 양쪽 끝에서 삽입/삭제 가능

**활용 사례**:
- BFS 알고리즘
- 작업 스케줄링
- 프린터 대기열
- 캐시 구현 (LRU)

## 그래프
정점(Vertex)과 간선(Edge)으로 구성된 자료구조입니다.

**그래프 종류**:
- **방향/무방향 그래프**: 간선에 방향성 유무
- **가중/비가중 그래프**: 간선에 가중치 유무
- **연결/비연결 그래프**: 모든 정점이 연결되어 있는지 여부
- **순환/비순환 그래프**: 사이클 존재 여부

**표현 방법**:
1. **인접 행렬**: 2차원 배열로 표현
   - 공간 복잡도: O(V²)
   - 간선 존재 확인: O(1)
   - 모든 간선 순회: O(V²)

2. **인접 리스트**: 연결 리스트로 표현
   - 공간 복잡도: O(V + E)
   - 간선 존재 확인: O(degree)
   - 모든 간선 순회: O(V + E)

**그래프 탐색**:
- **DFS (깊이 우선 탐색)**: 스택 또는 재귀 사용
- **BFS (너비 우선 탐색)**: 큐 사용

**활용 사례**:
- 소셜 네트워크
- 지도/네비게이션
- 웹 크롤링
- 추천 시스템

## 힙이란
완전 이진 트리 기반의 자료구조로, 부모 노드와 자식 노드 간에 일정한 대소관계를 유지하는 구조입니다.

**종류**:
- **최대 힙(Max Heap)**: 부모 노드가 자식 노드보다 크거나 같음
- **최소 힙(Min Heap)**: 부모 노드가 자식 노드보다 작거나 같음

**특징**:
- 완전 이진 트리 구조
- 배열로 구현 가능
- 우선순위 큐 구현에 사용
- 힙 정렬에 활용

## 힙의 삽입, 삭제

### 삽입 과정
1. **완전 이진 트리의 마지막 위치에 새 노드 추가**
2. **상향식 힙화(Heapify Up)**: 부모와 비교하여 힙 조건 만족할 때까지 교환
3. **시간 복잡도**: O(log n)

```
예시 (최대 힙):
1. 마지막 위치에 삽입
2. 부모보다 크면 교환
3. 루트까지 또는 힙 조건 만족할 때까지 반복
```

### 삭제 과정
1. **루트 노드 제거** (최대값 또는 최소값)
2. **마지막 노드를 루트로 이동**
3. **하향식 힙화(Heapify Down)**: 자식들과 비교하여 힙 조건 만족할 때까지 교환
4. **시간 복잡도**: O(log n)

```
예시 (최대 힙):
1. 루트(최대값) 제거
2. 마지막 노드를 루트로 이동
3. 자식 중 더 큰 값과 교환
4. 리프까지 또는 힙 조건 만족할 때까지 반복
```

## 힙이 할수있는 것을 균형 이진 트리가 할수 있지않나?

**힙의 고유한 장점**:
- **구현 단순성**: 배열로 간단히 구현, 인덱스 계산 용이
- **메모리 효율성**: 포인터 불필요, 캐시 친화적
- **특정 연산 최적화**: 최대/최소값 접근이 O(1)
- **힙 정렬**: 제자리 정렬 가능

**균형 이진 트리의 한계**:
- 복잡한 구현 (회전, 균형 유지)
- 추가 메모리 오버헤드 (포인터, 균형 정보)
- 최대/최소값 접근이 O(log n)

**결론**: 용도에 따라 다름. 우선순위 큐나 힙 정렬에는 힙이 더 효율적입니다.

## 이진 탐색 트리
각 노드의 왼쪽 서브트리에는 해당 노드보다 작은 값, 오른쪽 서브트리에는 큰 값이 위치하는 이진 트리입니다.

**특징**:
- **중위 순회**: 정렬된 순서로 데이터 출력
- **탐색, 삽입, 삭제**: 평균 O(log n), 최악 O(n)
- **균형이 중요**: 편향 트리 시 성능 저하

**활용**:
- 동적 정렬 유지
- 범위 검색
- 사전, 데이터베이스 인덱스

## 이진 탐색 트리 삽입, 탐색, 삭제

### 탐색 과정
1. **루트부터 시작**
2. **찾는 값과 현재 노드 비교**
3. **작으면 왼쪽, 크면 오른쪽으로 이동**
4. **값을 찾거나 NULL에 도달할 때까지 반복**

### 삽입 과정
1. **탐색과 동일한 방식으로 위치 찾기**
2. **적절한 위치에 새 노드 생성**
3. **BST 속성 유지**

### 삭제 과정
**3가지 경우**:
1. **리프 노드**: 단순히 제거
2. **자식 하나**: 자식 노드로 대체
3. **자식 둘**: 중위 후속자(또는 전임자)로 대체 후 후속자 삭제

```
자식 둘인 경우:
1. 오른쪽 서브트리의 최소값(중위 후속자) 찾기
2. 해당 값으로 삭제할 노드 값 교체
3. 중위 후속자 노드 삭제
```

## 자가 균형 트리
삽입과 삭제 연산 후에도 자동으로 균형을 유지하는 이진 탐색 트리입니다.

**필요성**:
- 편향 트리 방지
- 모든 연산을 O(log n)으로 보장
- 일정한 성능 유지

**종류**:
- AVL 트리
- Red-Black 트리
- B-트리
- Splay 트리

## AVL
Adelson-Velsky and Landis가 발명한 최초의 자가 균형 이진 탐색 트리입니다.

**균형 조건**:
- 모든 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이가 최대 1

**회전 연산**:
- **LL 회전**: 우회전
- **RR 회전**: 좌회전  
- **LR 회전**: 좌회전 후 우회전
- **RL 회전**: 우회전 후 좌회전

**특징**:
- **엄격한 균형**: 최적의 탐색 성능
- **높은 삽입/삭제 비용**: 빈번한 회전
- **시간 복잡도**: 모든 연산 O(log n) 보장

## Red Black Tree
각 노드가 빨간색 또는 검은색을 가지는 자가 균형 이진 탐색 트리입니다.

**규칙**:
1. **루트는 검은색**
2. **모든 리프(NIL)는 검은색**
3. **빨간 노드의 자식은 모두 검은색**
4. **루트에서 리프까지 모든 경로의 검은 노드 수 동일**

**특징**:
- **느슨한 균형**: AVL보다 덜 엄격
- **효율적인 삽입/삭제**: 회전 횟수 적음
- **실용성**: C++ STL map, Java TreeMap에서 사용
- **시간 복잡도**: 모든 연산 O(log n)

**AVL vs Red-Black**:
- AVL: 더 균형잡힌, 탐색 최적화
- Red-Black: 삽입/삭제 효율적, 실용적

## 해시
키를 해시 함수를 통해 해시 테이블의 인덱스로 변환하여 데이터를 저장하는 자료구조입니다.

**구성 요소**:
- **해시 함수**: 키를 인덱스로 변환
- **해시 테이블**: 데이터를 저장하는 배열
- **충돌 처리**: 같은 인덱스로 매핑되는 경우 해결

**특징**:
- **평균 시간 복잡도**: O(1) 삽입, 탐색, 삭제
- **최악 시간 복잡도**: O(n) (모든 키가 같은 인덱스)
- **공간-시간 트레이드오프**: 메모리 사용량 vs 성능

**좋은 해시 함수 조건**:
- 계산이 빠름
- 균등 분포
- 결정적 (같은 키는 항상 같은 값)

## 충돌회피 방법

### 1. 체이닝 (Chaining)
같은 인덱스에 매핑되는 원소들을 연결 리스트로 관리

**장점**:
- 구현 간단
- 테이블 크기 제한 없음
- 삭제 용이

**단점**:
- 추가 메모리 필요
- 캐시 성능 저하

### 2. 개방 주소법 (Open Addressing)
충돌 발생 시 다른 빈 슬롯을 찾아 저장

**종류**:
- **선형 탐사**: 순차적으로 다음 슬롯 확인
- **제곱 탐사**: i² 간격으로 탐사
- **이중 해싱**: 두 번째 해시 함수 사용

**장점**:
- 메모리 효율적
- 캐시 친화적

**단점**:
- 클러스터링 현상
- 삭제 복잡
- 부하율 관리 필요

### 3. 로드 팩터 관리
```
로드 팩터 = 저장된 원소 수 / 테이블 크기
```
- **체이닝**: 1.0 이하 유지
- **개방 주소법**: 0.7 이하 유지
- **동적 크기 조절**: 임계값 초과 시 테이블 크기 2배 확장
